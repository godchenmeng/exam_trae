服务端统一更新接口开发需求（针对统一文件+数据库补丁机制）

概述
- 目标：为客户端统一更新器 Updater.exe 和 WPF 客户端提供服务端接口与资源，
  使一次更新可同时包含文件（ZIP 包）与数据库（SQLite SQL）补丁。
- 客户端行为概览：
  - WPF 的 UpdateCheckService 会调用 /api/version 获取最新版本并提示，或直接以 --packageUrl 启动 Updater。
  - WPF 的 DatabaseUpdateService 会在后台调用 /api/updates 探测补丁，
    若存在则以 --updatesUrl 启动 Updater，由 Updater 统一执行 file_zip 与 db_sql。

接口与协议
1) 版本检查接口：GET /api/version
- 请求参数：无（可扩展 clientVersion、platform、arch）
- 返回字段：
  - latest：字符串，最新版本号（例如 1.2.3）
  - minCompatibleClient：字符串，最低兼容客户端版本（可选）
  - notes：字符串，更新说明（可选）
  - downloadUrl：字符串，客户端安装包或 ZIP 更新包地址（可选）
- 示例返回：
  {
    "latest": "1.2.3",
    "minCompatibleClient": "1.1.0",
    "notes": "修复若干问题并提升性能",
    "downloadUrl": "https://updates.example.com/packages/app_1.2.3.zip"
  }

2) 统一补丁接口：GET /api/updates
- 请求参数：
  - clientVersion：字符串，客户端当前版本（WPF 会传入）
  - db：字符串，数据库类型（当前为 sqlite）
  - 可选：platform（windows）、arch（x64/x86）、role（客户端角色标识）、channel（灰度/稳定）、env（测试/生产）
- 返回结构：
  {
    "patches": [
      {
        "id": "2025-11-10-a",
        "type": "file_zip",
        "url": "https://updates.example.com/packages/app_1.2.3.zip",
        "expectedVersion": "1.2.3",
        "sha256": "c0ffee...deadbeef..."  
      },
      {
        "id": "2025-11-10-b",
        "type": "db_sql",
        "sql": "ALTER TABLE t_user ADD COLUMN nickname TEXT;\nUPDATE t_user SET nickname='';"
      }
    ]
  }
- 字段约束：
  - patches：数组，顺序即执行顺序。
  - id：字符串，补丁唯一标识（建议全局唯一且稳定）。
  - type：字符串，取值为 file_zip 或 db_sql。
  - file_zip：必须包含 url（HTTP/HTTPS 可下载），可选 expectedVersion、sha256。
  - db_sql：必须包含 sql（多语句以分号结尾，Updater 按分号拆分并在事务中执行）。
- 业务规则：
  - 服务端需按 clientVersion、channel、role 等策略返回合适的补丁集合。
  - 若没有补丁，返回 patches 为空数组或省略，客户端将跳过执行。
  - id 用于客户端去重，重复 id 不会重复执行。

文件补丁（file_zip）要求
- 包结构：解压后覆盖至应用目录（AppContext.BaseDirectory）。
- 需包含被替换的所有文件（支持增量覆盖，未包含的文件保留）。
- 建议在包内包含 Updater 使用的变更文件，而非数据库文件（数据库由 db_sql 迁移）。
- 校验：建议提供 sha256 字段用于完整性校验（Updater 会比对）。
- 版本：如配合 /api/version 提示用户更新，应确保 expectedVersion 与 latest 一致或可验证。

数据库补丁（db_sql）要求
- 仅支持 SQLite；sql 字符串中包含一条或多条语句，以分号分隔。
- Updater 会在事务中逐条执行，任何一条失败将回滚该补丁。
- 请避免长事务锁和外键破坏：
  - 尽量使用快速的 DDL/DML；必要时分批处理。
  - 若涉及外键约束，请谨慎编排语句顺序与约束开关。
- 兼容性：确保在旧版本数据库结构上也可安全执行（或基于 clientVersion 进行适配）。
- 幂等性：优先编写幂等 SQL，例如使用 IF NOT EXISTS 检查列/表是否存在。

安全与鉴权
- HTTPS 强制启用，避免补丁在传输中被篡改。
- 可选鉴权方式：
  - 服务器对 /api/updates、/api/version 进行 IP 白名单策略或 API Key/JWT 校验。
  - 对下载包 URL 进行短期签名（如 SAS/临时签名），限制时间窗口与来源。
- 速率限制与防滥用：按客户端标识或 IP 进行限流与审计。

错误码与返回约定
- /api/version：失败返回 5xx 或 4xx，body 可包含 { error, message }。
- /api/updates：失败返回 5xx 或 4xx，建议返回 { error, message }；
  正常但无补丁时返回 { patches: [] }。

服务端参考实现（伪代码/范式）
- Node.js（Express）示例：
  // 仅示意
  GET /api/version => {
    latest: env.LATEST_VERSION,
    minCompatibleClient: env.MIN_CLIENT,
    notes: "...",
    downloadUrl: makeDownloadUrl(env.LATEST_ZIP)
  }
  GET /api/updates => {
    const q = req.query;
    const clientVersion = q.clientVersion;
    const db = q.db; // sqlite
    const role = q.role || 'default';
    const patches = selectPatches(clientVersion, role);
    return { patches };
  }

- ASP.NET Core（C#）示例：
  GET /api/version -> 返回 VersionInfo DTO
  GET /api/updates -> 返回 UpdatesResponse DTO，内部根据策略组装 Patch 列表

使用示例（客户端交互）
- 版本检查：
  curl "https://updates.example.com/api/version"

- 统一补丁：
  curl "https://updates.example.com/api/updates?clientVersion=1.2.0&db=sqlite&role=student"

- 文件下载：
  curl -O "https://updates.example.com/packages/app_1.2.3.zip"

部署与配置
- 环境变量建议：
  - LATEST_VERSION：当前最新版本号
  - MIN_CLIENT_VERSION：最低兼容客户端版本
  - PACKAGES_BASE_URL：更新包基础地址
  - CHANNEL_DEFAULT：默认发布通道（stable/canary）
  - PATCH_JSON_PATH：可选，补丁配置文件路径（便于离线管理）
- 存储建议：
  - ZIP 包可存放在对象存储/CDN，提供可公开或受限访问 URL。
  - 补丁配置可存数据库或配置文件，保证服务端可按策略组装返回。

关键业务规则与约束
- 补丁 id 必须唯一且稳定，用于客户端去重；一旦发布不可更改。
- 补丁顺序即执行顺序；若多条 db_sql 之间有依赖，应在同一个补丁 sql 中编排或拆分保证顺序。
- 灰度发布：可通过 channel/role 等参数控制补丁下发范围，避免全量风险。
- 兼容策略：服务端需根据 clientVersion 判断是否下发某些迁移（避免旧客户端无法应用）。

测试与验收
- 单元测试：
  - /api/version 返回字段完整性与类型正确性。
  - /api/updates 在不同 clientVersion/role/channel 输入下返回正确的 patches 集合。
- 端到端测试：
  1) 设置客户端环境变量 UPDATE_SERVER_URL 指向测试服务端。
  2) 返回 patches 同时包含 file_zip 与 db_sql。
  3) 启动客户端后，DatabaseUpdateService 探测到补丁并启动 Updater。
  4) Updater 执行 ZIP 文件替换与 SQLite SQL 迁移，写入 %AppData%/ExamSystem/db-patches.json。
  5) 客户端被自动重启，验证功能与数据库结构已更新。
- 验收标准：
  - 不同场景（无补丁/仅文件/仅数据库/同时）均正常执行且可回滚。
  - 文件包完整性校验通过；数据库迁移幂等、事务回滚正常。
  - 审计日志记录到位（访问日志、错误日志）。

开发 Checklist（提示词）
- [ ] /api/version DTO 与序列化字段名严格对齐：latest、minCompatibleClient、notes、downloadUrl。
- [ ] /api/updates 返回 patches 数组，每项包含 id、type、sql/url、expectedVersion/sha256（按类型）。
- [ ] 根据 clientVersion/role/channel 等参数进行补丁选择与排序。
- [ ] ZIP 包托管与 URL 生成策略明确，必要时提供短期签名与访问控制。
- [ ] 补丁 id 全局唯一，建立生成与校验流程，避免重复。
- [ ] 灰度与回滚方案明确：如何撤回错误补丁、如何快速置空返回以止损。
- [ ] 记录访问日志与错误日志，便于定位问题与审计。
- [ ] 编写端到端联调脚本与测试用例，覆盖典型路径与异常路径。

注意事项
- 客户端 Updater 会先等待进程退出再替换文件；
  请避免在补丁应用时再强行修改正在运行的文件。
- db_sql 迁移应避免长事务与复杂锁，必要时拆分补丁或分阶段执行。
- 若需要按用户或组织维度控制补丁下发，请在接口参数或标头增加标识并在服务端策略中使用。

附录：数据结构参考
- VersionInfo DTO：
  - latest: string
  - minCompatibleClient: string (optional)
  - notes: string (optional)
  - downloadUrl: string (optional)

- UpdatesResponse DTO：
  - patches: Patch[]

- Patch DTO：
  - id: string
  - type: string (file_zip | db_sql)
  - sql: string (for db_sql)
  - url: string (for file_zip)
  - expectedVersion: string (optional)
  - sha256: string (optional)

—

Spring Boot 技术栈与 CentOS 部署实现指南

环境与技术栈要求
- 操作系统：CentOS 7/8（或 Rocky/Alma Linux）。
- Java：JDK 17（建议使用 Temurin/OpenJDK 17）。
- 框架：Spring Boot 3.x。
- 构建工具：Maven 3.8+（或 Gradle 7+）。
- 反向代理与 TLS：Nginx（建议开启 HTTPS）。
- 可选：Redis/MariaDB 用于补丁策略存储与审计；也可先用 YAML/JSON 配置文件。

项目结构建议
- exam-updates-server/
  - src/main/java/com/example/examupdates/
    - controller/
      - VersionController.java
      - UpdatesController.java
    - service/
      - PatchService.java
    - model/
      - VersionInfo.java
      - UpdatesResponse.java
      - Patch.java
    - util/
      - Sha256Util.java
  - src/main/resources/
    - application.yml
    - patches.yaml （可选：补丁配置文件）
  - pom.xml

Maven 依赖示例（pom.xml 片段）
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
  </dependency>
  <!-- 可选：安全与鉴权 -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
  </dependency>
  <!-- 可选：OpenAPI 文档 -->
  <dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.5.0</version>
  </dependency>
</dependencies>

配置文件（application.yml 示例）
server:
  port: 8080
exam:
  latestVersion: "1.2.3"
  minCompatibleClient: "1.1.0"
  notes: "修复若干问题并提升性能"
  packagesBaseUrl: "https://updates.example.com/packages"
  defaultChannel: "stable"
  # 可选：用于鉴权的 API Key（示例）
  apiKey: "REPLACE_ME_SECURE_KEY"

DTO 模型（Java 示例）
// model/VersionInfo.java
public class VersionInfo {
  private String latest;
  private String minCompatibleClient;
  private String notes;
  private String downloadUrl;
  // getters/setters
}

// model/Patch.java
public class Patch {
  private String id;
  private String type; // file_zip | db_sql
  private String sql;  // for db_sql
  private String url;  // for file_zip
  private String expectedVersion;
  private String sha256;
  // getters/setters
}

// model/UpdatesResponse.java
import java.util.List;
public class UpdatesResponse {
  private List<Patch> patches;
  // getters/setters
}

工具类（计算 ZIP 文件 sha256，可选）
// util/Sha256Util.java
import java.io.FileInputStream;
import java.security.MessageDigest;
public class Sha256Util {
  public static String sha256Hex(String filePath) {
    try (FileInputStream fis = new FileInputStream(filePath)) {
      MessageDigest md = MessageDigest.getInstance("SHA-256");
      byte[] buf = new byte[8192];
      int len;
      while ((len = fis.read(buf)) > 0) md.update(buf, 0, len);
      byte[] h = md.digest();
      StringBuilder sb = new StringBuilder();
      for (byte b : h) sb.append(String.format("%02x", b));
      return sb.toString();
    } catch (Exception e) {
      return null;
    }
  }
}

Service 层（补丁选择逻辑示例）
// service/PatchService.java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.util.ArrayList;
import java.util.List;

@Service
public class PatchService {
  @Value("${exam.latestVersion}")
  private String latestVersion;
  @Value("${exam.minCompatibleClient}")
  private String minCompatibleClient;
  @Value("${exam.notes}")
  private String notes;
  @Value("${exam.packagesBaseUrl}")
  private String packagesBaseUrl;

  public VersionInfo getVersionInfo() {
    VersionInfo info = new VersionInfo();
    info.setLatest(latestVersion);
    info.setMinCompatibleClient(minCompatibleClient);
    info.setNotes(notes);
    info.setDownloadUrl(packagesBaseUrl + "/app_" + latestVersion + ".zip");
    return info;
  }

  public UpdatesResponse getPatches(String clientVersion, String db, String role, String channel) {
    List<Patch> list = new ArrayList<>();
    // 示例：当客户端版本低于 latestVersion 时，下发文件与数据库补丁
    if (clientVersion == null || !clientVersion.equals(latestVersion)) {
      Patch zip = new Patch();
      zip.setId("pkg-" + latestVersion);
      zip.setType("file_zip");
      zip.setUrl(packagesBaseUrl + "/app_" + latestVersion + ".zip");
      zip.setExpectedVersion(latestVersion);
      // zip.setSha256(Sha256Util.sha256Hex("/opt/examserver/packages/app_" + latestVersion + ".zip"));
      list.add(zip);

      Patch sql = new Patch();
      sql.setId("db-" + latestVersion);
      sql.setType("db_sql");
      sql.setSql("ALTER TABLE t_user ADD COLUMN nickname TEXT;\nUPDATE t_user SET nickname='';");
      list.add(sql);
    }
    UpdatesResponse resp = new UpdatesResponse();
    resp.setPatches(list);
    return resp;
  }
}

Controller 层（接口定义示例）
// controller/VersionController.java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Autowired;

@RestController
public class VersionController {
  @Autowired private PatchService patchService;
  @GetMapping("/api/version")
  public VersionInfo version() {
    return patchService.getVersionInfo();
  }
}

// controller/UpdatesController.java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Autowired;

@RestController
public class UpdatesController {
  @Autowired private PatchService patchService;
  @GetMapping("/api/updates")
  public UpdatesResponse updates(
      @RequestParam(name = "clientVersion", required = false) String clientVersion,
      @RequestParam(name = "db", required = false, defaultValue = "sqlite") String db,
      @RequestParam(name = "role", required = false, defaultValue = "default") String role,
      @RequestParam(name = "channel", required = false, defaultValue = "stable") String channel
  ) {
    return patchService.getPatches(clientVersion, db, role, channel);
  }
}

基础安全（可选）
- 简易 API Key 校验：
  - 在 Nginx 或 Spring Security 中要求请求头 X-API-Key。
  - Spring Security 示例：自定义过滤器校验请求头，非法则返回 401。
- 强制 HTTPS：通过 Nginx 终止 TLS，后端只开放 127.0.0.1:8080。

Nginx 反向代理与 TLS 示例（/etc/nginx/conf.d/updates.conf）
server {
  listen 443 ssl http2;
  server_name updates.example.com;
  ssl_certificate     /etc/letsencrypt/live/updates.example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/updates.example.com/privkey.pem;

  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass http://127.0.0.1:8080/;
  }
}

systemd 服务文件（/etc/systemd/system/examupdates.service）
[Unit]
Description=Exam Updates Server (Spring Boot)
After=network.target

[Service]
User=examserver
WorkingDirectory=/opt/examupdates
ExecStart=/usr/bin/java -jar /opt/examupdates/exam-updates-server.jar --spring.config.location=/etc/examupdates/application.yml
Restart=always
RestartSec=10
Environment=JAVA_TOOL_OPTIONS=-Xms128m -Xmx512m

[Install]
WantedBy=multi-user.target

CentOS 部署步骤（示例）
1) 安装 Java 17：
   sudo yum install -y java-17-openjdk
2) 创建目录与用户：
   sudo useradd -r -s /sbin/nologin examserver || true
   sudo mkdir -p /opt/examupdates /etc/examupdates /opt/examupdates/packages
   sudo chown -R examserver:examserver /opt/examupdates /etc/examupdates
3) 构建并上传：
   mvn -q -DskipTests package
   scp target/exam-updates-server.jar root@server:/opt/examupdates/
   scp application.yml root@server:/etc/examupdates/
   scp app_1.2.3.zip root@server:/opt/examupdates/packages/
4) 配置 Nginx 与证书，启用服务：
   sudo systemctl enable --now examupdates
   sudo systemctl restart nginx
5) 防火墙放行 443（如需）：
   sudo firewall-cmd --permanent --add-service=https && sudo firewall-cmd --reload

联调与验证（curl 示例）
- 版本检查：
  curl -s https://updates.example.com/api/version | jq
- 补丁接口：
  curl -s "https://updates.example.com/api/updates?clientVersion=1.2.0&db=sqlite&role=student" | jq
- ZIP 下载：
  curl -s -O https://updates.example.com/packages/app_1.2.3.zip

开发提示词 Checklist（Spring Boot 专用）
- [ ] 控制器 URL 与字段名严格对齐（/api/version 与 /api/updates）。
- [ ] DTO 使用 Jackson 默认命名约定（小驼峰），确保客户端大小写不敏感解析兼容。
- [ ] 根据 clientVersion/role/channel 选择与排序补丁；id 唯一稳定。
- [ ] ZIP 包的路径与 URL 生成一致；如提供 sha256，服务端需计算并填充。
- [ ] 日志与审计：记录请求、响应与错误；必要时加入访问限制与告警。
- [ ] Nginx/HTTPS/systemd 配置完成并自启动；日志文件位置与轮换策略明确。
- [ ] 编写端到端联调脚本（curl + 验证 JSON 字段）；准备至少一个 file_zip 与一个 db_sql 补丁。
- [ ] 灰度与回滚策略：按 channel 或标识仅下发给部分客户端，出现问题时可快速返回空 patches。